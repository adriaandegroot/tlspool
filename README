TLSPOOL README
==============

The tlspool package concentrates TLS-use by client and server applications.
It gets passed a file descriptor of a socket, initiates TLS over it, and
then passes back a new, TLS-protected socket to the originator.  This makes
it very straightforward to add TLS support to network software, and the
central location of the TLS Pool makes it easy to enforce consistent rules
for authentication and authorization rules.


Proof of Concept code included
------------------------------

Currently, this work is in a proof-of-concept state, and programmed in
Python.  This has been the work of a couple of students who wrote in Python,
and it should be seen as a first demonstration of the idea of a TLS Pool.
It is not at production level, documentation is rather limited, but it
may be used for demonstration purposes.

Note that this early TLS daemon uses the major concept, namely that of
file descriptor exchange between application and TLS Pool, but the rest
of the API has not been explicitly designed; expect this specific API
to change.

Also note that the DANE implementation only works for the publication of
hashes of certificates, not for its other forms.  This means that the
code is only usable in situations where the remote party can be trusted
to implement this sort of thing.


Full-blown daemon development
-----------------------------

The actual daemon design is part of the plans of the Network Effect Alliance,
which aims to improve everyone's Internet quality through distribution of
more protocols and facilities under privately owned domain names.  The
full stretch of this project is documented on the website,

http://www.networkeffectalliance.org/

We are currently at a state where the daemon and a small stub library for
applications are working, and simple ANON-DH encryption-only TLS.  So, even
though you can ask for STARTTLS to be setup, it won't authenticate and it
won't even attempt to exchange identity information.

What it WILL do, is setup all the plumbing for an exchange that provides a
place for this to be added.  It is built like this:

- src/tlspool is a daemon that provides the centralised STARTTLS service.
- lib/libstarttls.so / .a provide a stub library for applications.
- lib/testsrv is a test server using immediate STARTTLS on incoming TCP.
- lib/testcli is a test client using immediate STARTTLS on outgoing TCP.

These can be run on one system (testcli and testsrv connect on localhost
port 12345) to setup a line-based chat system between client and server.
Note that the server will only respond to one client at a time; it is a
mere test program that wants to show the chat on the server console.

The core logic used here is (client shown, server is similar):

	#include <tlspool/starttls.h>
	...
	fd = starttls_client (fd, ...);
	...

The daemon will cover TCP, UDP and SCTP over IPv4 and IPv6.  Asynchronous
versions of these calls are under design, but their use is obvious and the
API to the TLS Pool has been designed to support it.

The daemon will provide configurable hooks for authentication and
authorization; this can then be setup for the entire system at once.
The resulting information of both authentication and authorization will be
shared using memcached, to simplify sharing of outcome not just accross
time and between protocols, but also between different servers.  The design
goal of memcached is to avoid repeated checks and repeated access to
remotely stored information, until a certain caching time has passed.

CURRENT STATUS: The daemon starts, parses configuration directives and
processes most of them.  The actual service is a full connection with
all the plumbing for setting it up and tearing it down gracefully,
but the only part of TLS that has been implemented is ANON-DH, which
does encrypt the connection, but without any authentication or identity
exchange.


The importance of PKCS #11
--------------------------

The key material used by this daemon will be accessed over PKCS #11.  This
requires multi-layered attacks to key material: the material is protected
by a secure key store of choice, in hardware or software, and even the PIN
for using the private keys without seeing them is stored in a separate
program, namely the TLS Pool.  Specifically, the PIN and key material are
not available to user agents such as a PHP-enabled web server which may
be running outdated software.

Aside from the improved key protection and the ability to choose a security
level by choosing the PKCS #11 implementation accordingly, it is useful to
have a central location for key storage; this simplifies maintenance tasks,
such as certificate renewals and (PIN encrypted) secret key backup.

One last advantage of using PKCS #11 is that this enables a form where
USB token manufacturers can provide a tool that functions as a HTTP proxy,
and that establishes secure connections to selected parties with an OpenPGP
key and no further infrastructure.  End users can plugin their token to
get secured access, and remove it to stop further secure web connections.
Note that this principle can easily be extended to other protocols that
can work through a proxy.

Note that it is expressly not the task of the TLS Pool to manage the
objects stored behind the PKCS #11 API.  This is expressly left to
external tools that manage certificates and keys on behalf of the
application area covered.  All the TLS Pool does is read tokens, looking
for usable keys to authenticate its identities to the Internet, both over
X.509 and over OpenPGP.

One final, and hardly recognised use of having a central TLS Pool and
potentially centralised PKCS #11 repositories is the ability to sniff
the network traffic for intrusion attempts.  To be able to do this in
the presence of encrypted connections, the ability to decrypt the
traffic must be offered to sniffers like Snort.  The decryption usually
involves manual input of certificates and private keys, which is no
longer necessary with PKCS #11 with remote access to the API in place.
So, large-scale organisations could setup a networked HSM and use it
both for production use and for feeding the intrusion detectors.


Additional Rules: RADIUS
------------------------

TODO: Can RADIUS handle user@domain for both the user and the realm?

Local environments may have their own added requirements to authentication,
authorization and also pursue their own accounting of TLS connections.  The
common approach to these mechansims is RADIUS, which can independently
handle these three types of request.  RADIUS is designed as a fast local
protocol, and it can be rerouted with FreeRADIUS and resolved with scripts
or programs in just about any programming language.

Any AAA facilities are stacked on top of the minimum requirements offered
by the TLS Pool, that is the identities of the peers can be assumed to
have been established (or perhaps be established in parallel) while the
authentication and authorization is requested.  Note that accounting
will always wait for completion of the identity check, to avoid charging
to an innocent account.

Note that RADIUS combines authentication and authorization into one accept
phase, which is supposed to do both.  This means that in practice most
people will declare RADIUS for either authentication or authorization.
This is not a requirement though; the functions can be setup and, due to
lack of expressiveness in the protocol, split over different servers.

Accounting is not usually applied immediately when a TLS connection is
setup; this is barely useful information.  Instead, the TLS Pool is able
to receive accounting requests over the same API as it uses for the
authentication and authorization requests, and it can pass requests on
to the accounting functions of a RADIUS service.

Accounting in the style of the TLS Pool comes down to counting ticks or
time; a series of values is supplied to both the start and end that is
being accounted:

 - an identifier for the kind of thing being accounted;
 - an identifier for the instance being accounted;
 - a local and remote identity of a user@domain or of a domain.

For each of these, information is collected to support accounting:

 - the identifier for the kind of thing being accounted;
 - the identifier for the instance being accounted;
 - the local and remote identity of a user@domain or of a domain;
 - a timestamp for the start and, if present, the end of a period;
 - a final count representing the number of items being accounted.

