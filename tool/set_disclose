#!/usr/bin/python
#
# tlspool/set_disclose.py -- Setup disclosure for local client identities
#
# Provide a database, a selector for remote peers to and a list of local DoNAIs.
# The command erases all matching old entries.
#
# This program was created for test/development purposes only.
#
# Dependency: The python-bsddb module
#
# From: Rick van Rein <rick@openfortress.nl>


import sys

from bsddb import db


usage = """Usage: %s disclose.db selector [[user@]domain...]
 - disclose.db           is the database with local identities
 - selector              is a matcher for remote peer identities
 - user@domain or domain is a local client network access identifier
The list of client identities replaces the old list.  An empty list is nothing
special; it replaces the old content with zero entries.
The selector may take the following forms:
 - domain      matches remote peer DoNAI  completely but    with no username
 - .domain     matches remote peer DoNAIs ending in .domain with no username
 - .           matches any remote peer                      with no username
 - user@domain matches remote peer DoNAI  with the username given
 - @domain     matches remote peer DoNAIs with any username
 - @.domain    matches remote peer DoNAIs with any username ending in .domain
 - @.          matches remote peer DoNAIs with any username and any domain
When multiple selectors match a remote DoNAI, only the most concrete applies.
When no selector matches a remote DoNAI, the default policy is to reject.
NOTE:TODO: You may need to restart the tlspool after changes (why?!?)
""";


#
# Create an environment for transactions
#
env = db.DBEnv ()
print 'Opening database environment'
env.open ('../testdata', db.DB_CREATE | db.DB_RECOVER | db.DB_INIT_TXN | db.DB_INIT_LOCK | db.DB_INIT_LOG | db.DB_THREAD | db.DB_INIT_MPOOL)
if env:
	print 'Starting transaction'
	txn = env.txn_begin ()
else:
	print 'No environment, so not beginning a transaction'


#
# Parse the commandline
#
if len (sys.argv) < 3:
	sys.stderr.write (usage % sys.argv [0])
	sys.exit (1)

try:
	dbh = db.DB (dbEnv=env)
	dbh.set_flags (db.DB_DUP)
	dbh.open (sys.argv [1], dbtype=db.DB_HASH, flags=db.DB_CREATE, txn=txn)
except:
	sys.stderr.write ('%s: Failed to open database %s\n' % (sys.argv [0], sys.argv [1]))
	raise

selector = sys.argv [2]


#
# First, delete old value(s) for this selector
#
crs = dbh.cursor (txn=txn)
obj = crs.get (selector, db.DB_SET)
while obj:
	disclosed = obj [1]
	print 'Concealing', disclosed, 'from', selector
	crs.delete ()
	obj = crs.next_dup ()
crs.close ()

#
# Then, add the new value(s) for this selector
#
for disclosed in sys.argv [3:]:
	print 'Disclosing', disclosed, 'to', selector
	dbh.put (selector, disclosed, txn=txn)

#
# Two-phase commit is overkill... but it's good to practice a bit ;-)
#
if txn:
	#NOTYET# print 'Preparing to commit transaction'
	#NOTYET# txn.prepare ('x' * db.DB_GID_SIZE)
	print 'Committing transaction'
	txn.commit ()
	print 'Done'
else:
	print 'No transaction to finish properly'

dbh.close ()

if env:
	env.close ()
else:
	print 'No environment to close'

