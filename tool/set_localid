#!/usr/bin/python
#
# tlspool/set_localid.py -- Add local identity credential */
#
# Provide a database, a NAI and a type of credential.
# The command erases all matching old entries.
# Add the PKCS #11 URI and binary file public file, if provided.
#
# This program was created for test/development purposes only.
#
# Dependency: The python-bsddb module
#
# From: Rick van Rein <rick@openfortress.nl>


import sys
import struct

from bsddb import db


usage = """Usage: %s localid.db [user@]fqdn type [p11priv pubdata...]
 - localid.db        is the database with local identities
 - user@fqdn or fqdn is a network access identifier
 - type              comma-sep: X.509 or OpenPGP, and client or server
 - p11priv           is a PKCS #11 URI string for the private key
 - pubdata           is a file name    string for the public key package
The pairs of p11priv and pubdata replace the old content.  An empty list of
pairs is nothing special; it replaces the old content with zero entries.
NOTE:TODO: You may need to restart the tlspool after changes (why?!?)
""";

typemap = {
	'x.509': 1,
	'x509': 1,
	'openpgp': 2,
	'cli': 256,
	'srv': 512,
	'client': 256,
	'server': 512,
}


#
# Create an environment for transactions
#
env = db.DBEnv ()
print 'Opening database environment'
env.open ('../testdata', db.DB_CREATE | db.DB_RECOVER | db.DB_INIT_TXN | db.DB_INIT_LOCK | db.DB_INIT_LOG | db.DB_THREAD | db.DB_INIT_MPOOL)
if env:
	print 'Starting transaction'
	txn = env.txn_begin ()
else:
	print 'No environment, so not beginning a transaction'


#
# Parse the commandline
#
if len (sys.argv) < 4 or len (sys.argv) % 2 != 0:
	sys.stderr.write (usage % sys.argv [0])
	sys.exit (1)

try:
	dbh = db.DB (dbEnv=env)
	dbh.set_flags (db.DB_DUP)
	dbh.open (sys.argv [1], dbtype=db.DB_HASH, flags=db.DB_CREATE, txn=txn)
except:
	sys.stderr.write ('%s: Failed to open database %s\n' % (sys.argv [0], sys.argv [1]))
	raise

localid = sys.argv [2]

try:
	reqtp = 0
	for tp in sys.argv [3].lower ().split (','):
		reqtp = reqtp | typemap [tp]
except:
	sys.stderr.write ('%s: Unsupported key type %s\n' % (sys.argv [0], sys.argv [3]))
	sys.exit (1)

pairs = []
idx = 4
while len (sys.argv) > idx:
	p11priv = sys.argv [idx+0]
	if p11priv [:7] != 'pkcs11:':
		sys.stderr.write ('%s: PKCS #11 URIs start with "pkcs11:"\n' % sys.argv [0])
		print '(Ignored)' #TODO:ADD:PKCS11# sys.exit (1)
	pubdata = open (sys.argv [idx+1], 'r').read ()
	pairs.append ( (p11priv,pubdata) )
	idx = idx + 2

#
# First, delete old value(s) of the matching type
#
crs = dbh.cursor (txn=txn)
obj = crs.get (localid, db.DB_SET)
while obj:
	(objtp,) = struct.unpack (">I", obj [1][:4])
	print 'Object type is', objtp
	(p11priv,pubdata) = obj [1][4:].split ('\x00', 1)
	if (objtp & 0xff) == (reqtp & 0xff):
		print 'Deleting old entry', objtp, p11priv, '#' + str (len (pubdata))
		crs.delete ()
	else:
		print 'Won\'t unpack, type is %d and not %d' % (objtp, reqtp)
	obj = crs.next_dup ()
crs.close ()

#
# Then, enter new value(s)
#
for (p11priv,pubdata) in pairs:
	print 'Packing request type', reqtp
	data = struct.pack (">I", reqtp) + p11priv + '\x00' + pubdata
	print 'Adding new entry', reqtp, p11priv, '#' + str (len (pubdata))
	dbh.put (localid, data, txn=txn)

#
# Two-phase commit is overkill... but it's good to practice a bit ;-)
#
if txn:
	#NOTYET# print 'Preparing to commit transaction'
	#NOTYET# txn.prepare ('x' * db.DB_GID_SIZE)
	print 'Committing transaction'
	txn.commit ()
	print 'Done'
else:
	print 'No transaction to finish properly'

dbh.close ()

if env:
	env.close ()
else:
	print 'No environment to close'

